clc; clear; close all;

%% 1. Caricamento File
[filename, pathname] = uigetfile('*.csv', 'Seleziona il file CSV TableA');
if isequal(filename,0), error('Nessun file selezionato.'); end
T = readtable(fullfile(pathname, filename));

% --- UNIFORMITÀ NOMI ---
% Usiamo T come tabella di riferimento principale per tutto lo script
vars = {'End_Pause_ts','Reg_Click_Start_ts','Creak_Start_ts','Pause_Start_ts'};
for v = 1:length(vars)
    if ~isduration(T.(vars{v})), T.(vars{v}) = duration(T.(vars{v})); end
end

[audioFileName, audioPath] = uigetfile('*.wav', 'Seleziona il file WAV');
[audioData, Fs] = audioread(fullfile(audioPath, audioFileName));

%% 2. Configurazione Deployment
dpChoice = menu('Deployment?', 'DP1', 'DP2');
if dpChoice == 1
    wavStartTime = datetime('13:02:00.820','InputFormat','HH:mm:ss.SSS');
else
    wavStartTime = datetime('14:05:06.860','InputFormat','HH:mm:ss.SSS');
end
wavStart_dur = duration(hour(wavStartTime), minute(wavStartTime), second(wavStartTime));

%% 3. Caricamento PRH Smoothed
[csvPRHFile, csvPRHPath] = uigetfile('*.csv', 'Seleziona il CSV con PRH_smoothed');
if isequal(csvPRHFile,0), error('Caricamento CSV annullato.'); end
T_prh = readtable(fullfile(csvPRHPath, csvPRHFile));

%% 4. Configurazione Parametri e Cartelle
saveFolder = uigetdir(pwd, 'Seleziona cartella di output per i grafici');
if isequal(saveFolder,0), error('Cartella non selezionata.'); end

% Definiamo myTable partendo da T (caricata nella Sezione 1)
myTable = T; 

% Parametri necessari per il plotting
if ~exist('fs_sensor','var'), fs_sensor = 10; end
sensitivity_dB = -165; 
calib_factor = 10^(sensitivity_dB/20);

%% 5. Plotting con Nitidezza, Saturazione e Durata Dinamica
fprintf('\nGenerazione grafici in corso...\n');
for k = 1:height(myTable)
    % --- 1. CALCOLO TEMPI, OFFSET E DURATA ---
    t_ep = myTable.End_Pause_ts(k);
    t_rc = myTable.Reg_Click_Start_ts(k);
    t_ck = myTable.Creak_Start_ts(k);
    t_ps = myTable.Pause_Start_ts(k);
    
    t_evento_ref = t_ep;
    if isnan(t_evento_ref), t_evento_ref = t_rc; end
    if isnan(t_evento_ref), t_evento_ref = t_ck; end 
    
    % Calcolo durata effettiva della sequenza (senza i buffer di visualizzazione)
    dur_raw = seconds(t_ps - t_evento_ref);
    if dur_raw < 60
        dur_str = sprintf('%.0fs', dur_raw);
    else
        dur_min = floor(dur_raw/60);
        dur_sec = mod(dur_raw, 60);
        dur_str = sprintf('%dm %.0fs', dur_min, dur_sec);
    end

    start_sec = seconds(t_evento_ref - wavStart_dur) - 2; 
    end_sec   = seconds(t_ps - wavStart_dur) + 2;
    
    if end_sec <= start_sec, continue; end
    
    % --- 2. ESTRAZIONE E ANALISI AUDIO ---
    idxStart_audio = round(max(1, start_sec * Fs));
    idxEnd_audio   = round(min(length(audioData), end_sec * Fs));
    segment = audioData(idxStart_audio:idxEnd_audio);
    if isempty(segment), continue; end
    
    p_seg = segment / calib_factor; 
    nfft = 2048; 
    [~, F, T_s, P] = spectrogram(p_seg, hann(nfft), nfft/2, nfft, Fs);
    A = 10*log10(abs(P)); 
    
    % --- 3. ESTRAZIONE SENSORI ---
    sIdx_sensor = round(max(1, start_sec * fs_sensor));
    eIdx_sensor = round(min(height(T_prh), end_sec * fs_sensor));
    sensorRange = sIdx_sensor:eIdx_sensor;
    t_sensor = (sensorRange / fs_sensor) - start_sec;
    
    p_plot = T_prh.pitch_smoothed(sensorRange);
    r_plot = mod(T_prh.roll_smoothed(sensorRange) + 180, 360) - 180;
    h_plot = mod(T_prh.heading_smoothed(sensorRange) + 180, 360) - 180;
    r_plot(abs(diff([r_plot; r_plot(end)])) > 180) = NaN;
    h_plot(abs(diff([h_plot; h_plot(end)])) > 180) = NaN;
    
    % --- 4. FIGURA ---
    hFig = figure('Visible','off', 'Position', [100 100 1500 950]);
    tiledlayout(2, 1, 'TileSpacing', 'compact', 'Padding', 'compact');
    
    % PANNELLO 1: SPETTROGRAMMA
    ax1 = nexttile;
    imagesc(T_s, F/1000, A); 
    axis xy; colormap(ax1, jet);
    clim([30 115]); % Saturazione alta
    
    ylabel('Freq [kHz]', 'FontWeight', 'bold');
    
    actual_start_time = wavStart_dur + seconds(start_sec + 2);
    actual_start_time.Format = 'hh:mm:ss.SSS';
    
    % TITOLO AGGIORNATO CON DURATA
    title(sprintf('Seq #%d  |  Timestamp: %s  |  Index: %d  |  Duration: %s', ...
          k, char(actual_start_time), sIdx_sensor, dur_str), 'FontSize', 12);
    
    colorbar; hold on;
    
    % Marker Eventi
    ev_times = [t_ep, t_rc, t_ck, t_ps];
    ev_labels = {'EndPause', 'RegClick', 'Creak', 'Pause'};
    skip_next = false;
    for i = 1:4
        if skip_next, skip_next = false; continue; end
        if isnan(ev_times(i)), continue; end
        t_curr = seconds(ev_times(i) - wavStart_dur) - start_sec;
        label_str = ev_labels{i};
        if i == 1 && ~isnan(ev_times(2)) && abs(seconds(ev_times(2) - ev_times(1))) < 1
            label_str = 'RegClick';
            skip_next = true;
        end
        line([t_curr t_curr], [0 Fs/2000], 'Color', 'w', 'LineStyle', '--', 'LineWidth', 1.5);
        text(t_curr, (Fs/2000)*0.9, label_str, 'Color', 'k', ...
            'BackgroundColor', [1 1 1 0.7], 'Rotation', 90, 'FontWeight', 'bold', 'FontSize', 8);
    end

    % PANNELLO 2: SENSORI
    nexttile;
    yyaxis left
    plot(t_sensor, p_plot, 'r', 'LineWidth', 2); hold on;
    plot(t_sensor, r_plot, 'g--', 'LineWidth', 2);
    plot(t_sensor, h_plot, 'b:', 'LineWidth', 2);
    ylabel('Degrees (PRH)', 'FontWeight', 'bold'); 
    ylim([-190 190]); set(gca, 'YTick', -180:60:180); grid on;
    ax = gca; ax.YAxis(1).Color = 'k';
    
    yyaxis right
    plot(t_sensor, T_prh.depth_smoothed(sensorRange), 'k', 'LineWidth', 2.5);
    set(gca, 'YDir', 'reverse'); ylabel('Depth [m]', 'FontWeight', 'bold');
    ax.YAxis(2).Color = 'k';
    
    xlabel('Time [s]', 'FontWeight', 'bold');
    legend('Pitch', 'Roll', 'Head', 'Depth', 'Location', 'southoutside', 'Orientation', 'horizontal');
    xlim([T_s(1) T_s(end)]); 
    
    % Esportazione
    exportgraphics(hFig, fullfile(saveFolder, sprintf('Seq_%03d_Sync.png', k)), 'Resolution', 300);
    close(hFig);
end
fprintf('\n✅ Elaborazione completata.\n');
