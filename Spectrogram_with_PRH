clc; clear; close all;

%% 1 Caricamento File
[filename, pathname] = uigetfile('*.csv', 'Seleziona il file CSV TableA');
if isequal(filename,0), error('Nessun file selezionato.'); end
T = readtable(fullfile(pathname, filename));

% --- CONTROLLO NOMI COLONNE ---
% Verifichiamo se le colonne esistono. Se il tuo CSV usa nomi diversi, modificali qui.
vars = {'End_Pause_ts','Reg_Click_Start_ts','Creak_Start_ts','Pause_Start_ts'};
missingVars = vars(~ismember(vars, T.Properties.VariableNames));
if ~isempty(missingVars)
    disp('Nomi colonne trovati nel CSV:');
    disp(T.Properties.VariableNames);
    error('Il CSV non contiene le colonne: %s', strjoin(missingVars, ', '));
end

for v = 1:length(vars)
    if ~isduration(T.(vars{v})), T.(vars{v}) = duration(T.(vars{v})); end
end

[audioFileName, audioPath] = uigetfile('*.wav', 'Seleziona il file WAV');
[audioData, Fs] = audioread(fullfile(audioPath, audioFileName));

%% 2 Configurazione Deployment
dpChoice = menu('Deployment?', 'DP1', 'DP2');
if dpChoice == 1
    wavStartTime = datetime('13:02:00.820','InputFormat','HH:mm:ss.SSS');
else
    wavStartTime = datetime('14:05:06.860','InputFormat','HH:mm:ss.SSS');
end
wavStart_dur = duration(hour(wavStartTime), minute(wavStartTime), second(wavStartTime));

%% 3 Loop Plotting (lighter)
saveFolder = uigetdir(pwd, 'Seleziona cartella di output');
sensitivity_dB = -165; 
calib_factor = 10^(sensitivity_dB/20);

for k = 1:height(T_proc)
    % Se End_Pause è NA, facciamo partire l'estrazione 5s prima del RegClick
    if isnan(T_proc.End_Pause_ts(k))
        base_start = T_proc.Reg_Click_Start_ts(k) - seconds(5);
    else
        base_start = T_proc.End_Pause_ts(k);
    end
    
    start_sec = seconds(base_start - wavStart_dur) - 2; 
    end_sec   = seconds(T_proc.Pause_Start_ts(k) - wavStart_dur) + 2;
    
    if end_sec <= start_sec, continue; end
    
    % Estrazione audio mirata per saltare il surfacing
    idxStart = round(max(1, start_sec * Fs));
    idxEnd   = round(min(length(audioData), end_sec * Fs));
    segment  = audioData(idxStart:idxEnd);
    
    % Spettrogramma
    p = segment / calib_factor; 
    [~, F, T_s, P] = spectrogram(p, hann(2048), 1024, 2048, Fs);
    A = 10*log10(abs(P)); 
    
    hFig = figure('Visible','off', 'Position', [100 100 1200 600]);
    surf(T_s, F/1000, zeros(size(A)), A, 'EdgeColor', 'none'); 
    view(0, 90); axis tight; axis xy; clim([20 120]); colormap jet;
    
    cb = colorbar; cb.Title.String = '[dB re 1 \muPa^2/Hz]';
    xlabel('Time [s]'); ylabel('Frequency [kHz]'); hold on;
    
    % --- Etichette (Saltiamo EndPause se è NA) ---
    times = [T_proc.End_Pause_ts(k), T_proc.Reg_Click_Start_ts(k), ...
             T_proc.Creak_Start_ts(k), T_proc.Pause_Start_ts(k)];
    labels = {'EndPause', 'RegClick', 'Creak', 'Pause'};
    yPos = [0.85, 0.75, 0.65, 0.55] * (Fs/2000); % Scala in kHz
    
    for i = 1:4
        if ~isnan(times(i))
            t_ev = seconds(times(i) - wavStart_dur) - start_sec;
            line([t_ev t_ev], [0 Fs/2000], [2 2], 'Color', 'k', 'LineStyle', '-.');
            text(t_ev + 0.1, yPos(i), 5, labels{i}, 'BackgroundColor', 'w', ...
                'Rotation', 90, 'FontSize', 7, 'FontWeight', 'bold');
        end
    end
    
    % Titolo con gestione stringa NA
    title_ep = string(T_proc.End_Pause_ts(k));
    if isnan(T_proc.End_Pause_ts(k)), title_ep = "NA"; end
    title(sprintf('Sequence #%d | %s -> %s', k, title_ep, string(T_proc.Pause_Start_ts(k))), 'Interpreter', 'none');
    
    exportgraphics(hFig, fullfile(saveFolder, sprintf('%03d_Sequence.png', k)), 'Resolution', 200);
    close(hFig);
end
disp(' Processo completato.');
%% 3 Loop Plotting (Darker)
saveFolder = uigetdir(pwd, 'Seleziona cartella di output');
sensitivity_dB = -165; 
calib_factor = 10^(sensitivity_dB/20);

for k = 1:height(T_proc)
    % Logica base_start (Invariata per i NA)
    if isnan(T_proc.End_Pause_ts(k))
        base_start = T_proc.Reg_Click_Start_ts(k) - seconds(5);
    else
        base_start = T_proc.End_Pause_ts(k);
    end
    
    start_sec = seconds(base_start - wavStart_dur) - 2; 
    end_sec   = seconds(T_proc.Pause_Start_ts(k) - wavStart_dur) + 2;
    
    if end_sec <= start_sec, continue; end
    
    idxStart = round(max(1, start_sec * Fs));
    idxEnd   = round(min(length(audioData), end_sec * Fs));
    segment  = audioData(idxStart:idxEnd);
    
    % Spettrogramma
    p = segment / calib_factor; 
    [~, F, T_s, P] = spectrogram(p, hann(2048), 1024, 2048, Fs);
    A = 10*log10(abs(P)); 
    
    hFig = figure('Visible','off', 'Position', [100 100 1300 650]);
    surf(T_s, F/1000, zeros(size(A)), A, 'EdgeColor', 'none'); 
    
    % --- RITORNO AL JET CON FONDO CHIARO ---
    shading interp;      
    view(0, 90); axis tight; axis xy; 
    
    % IMPOSTAZIONE CHIAVE: 
    % Mettendo il minimo a 25 o 28, il fondo diventa un blu acceso (azzurro) 
    clim([28 115]);      
    
    colormap jet; % con fondo meno "pesante"
    
    cb = colorbar; cb.Title.String = '[dB re 1 \muPa^2/Hz]';
    xlabel('Time [s]'); ylabel('Frequency [kHz]'); hold on;
    
    % --- Etichette (Torniamo al Nero per massima visibilità) ---
    times = [T_proc.End_Pause_ts(k), T_proc.Reg_Click_Start_ts(k), ...
             T_proc.Creak_Start_ts(k), T_proc.Pause_Start_ts(k)];
    labels = {'EndPause', 'RegClick', 'Creak', 'Pause'};
    
    maxF = Fs/2000;
    yPos = [0.85, 0.75, 0.65, 0.55] * maxF;
    
    for i = 1:4
        if ~isnan(times(i))
            t_ev = seconds(times(i) - wavStart_dur) - start_sec;
            line([t_ev t_ev], [0 maxF], [5 5], 'Color', 'k', 'LineStyle', '--', 'LineWidth', 1);
            text(t_ev + 0.1, yPos(i), 10, labels{i}, 'BackgroundColor', 'w', ...
                'Rotation', 90, 'FontSize', 7, 'FontWeight', 'bold', 'EdgeColor', 'k', 'Margin', 1.5);
        end
    end
    
    title_ep = string(T_proc.End_Pause_ts(k));
    if isnan(T_proc.End_Pause_ts(k)), title_ep = "NA"; end
    title(sprintf('Sequence #%d | %s -> %s', k, title_ep, string(T_proc.Pause_Start_ts(k))), 'Interpreter', 'none');
    
    exportgraphics(hFig, fullfile(saveFolder, sprintf('%03d_Sequence.png', k)), 'Resolution', 300);
    close(hFig);
end
%% 4 .mat file
[matFile, matPath] = uigetfile('*.mat', 'Seleziona il file .mat con i dati PRH-Depth');
if isequal(matFile,0), error('Caricamento .mat annullato.'); end
matData = load(fullfile(matPath, matFile));
%% Multi-Panel Plotting: Spectrogram + PRH & Depth
saveFolder = uigetdir(pwd, 'Seleziona cartella di output');
sensitivity_dB = -165; 
calib_factor = 10^(sensitivity_dB/20);

% --- ASSEGNAZIONE VARIABILI DAL .MAT ---
pitch_vec = matData.pitch;
roll_vec  = matData.roll;
head_vec  = matData.head;
depth_vec = matData.p;
fs_sensor = matData.fs; % Frequenza campionamento sensori (es. 10 o 25)

for k = 1:height(T_proc)
    % 1. Determina Finestra Temporale
    if isnan(T_proc.End_Pause_ts(k))
        base_start = T_proc.Reg_Click_Start_ts(k) - seconds(5);
    else
        base_start = T_proc.End_Pause_ts(k);
    end
    
    start_sec = seconds(base_start - wavStart_dur) - 2; 
    end_sec   = seconds(T_proc.Pause_Start_ts(k) - wavStart_dur) + 2;
    if end_sec <= start_sec, continue; end
    
    % 2. Spettrogramma (Audio Fs)
    idxStart = round(max(1, start_sec * Fs));
    idxEnd   = round(min(length(audioData), end_sec * Fs));
    segment  = audioData(idxStart:idxEnd);
    
    nwin = 4096;
    noverlap = round(nwin * 0.9); 
    p_seg = segment / calib_factor; 
    [~, F, T_s, P] = spectrogram(p_seg, hann(nwin), noverlap, nwin, Fs);
    A = 10*log10(abs(P)); 
    
    % 3. Estrazione Dati Sensori (Usando fs_sensor)
    % Calcoliamo gli indici corretti per i sensori partendo dai secondi
    sIdx_sensor = round(max(1, start_sec * fs_sensor));
    eIdx_sensor = round(min(length(depth_vec), end_sec * fs_sensor));
    sensorRange = sIdx_sensor:eIdx_sensor;
    
    % Tempo relativo per il plot dei sensori (allineato allo spettrogramma)
    t_sensor = (sensorRange / fs_sensor) - start_sec;

    % 4. Creazione Figura
    hFig = figure('Visible','off', 'Position', [100 100 1500 900]);
    t_layout = tiledlayout(2, 1, 'TileSpacing', 'compact');

    % --- TOP TILE: Spectrogram ---
    nexttile;
    surf(T_s, F/1000, zeros(size(A)), A, 'EdgeColor', 'none'); 
    view(0, 90); axis tight; axis xy;
    shading interp; colormap(gca, jet); clim([28 110]);
    ylabel('Freq [kHz]', 'FontWeight', 'bold');
    title(sprintf('Sequence #%d | Acoustic & PRH Profile', k));
    cb = colorbar; cb.Label.String = 'dB re 1 \muPa^2/Hz';
    hold on;
    
    % Marker eventi
    times = [T_proc.End_Pause_ts(k), T_proc.Reg_Click_Start_ts(k), ...
             T_proc.Creak_Start_ts(k), T_proc.Pause_Start_ts(k)];
    labels = {'EndPause', 'RegClick', 'Creak', 'Pause'};
    for i = 1:4
        if ~isnan(times(i))
            t_ev = seconds(times(i) - wavStart_dur) - start_sec;
            line([t_ev t_ev], [0 Fs/2000], [15 15], 'Color', 'w', 'LineStyle', '--', 'LineWidth', 1.2);
            text(t_ev, (Fs/2000)*0.8, 20, labels{i}, 'BackgroundColor', 'w', 'Rotation', 90, 'FontSize', 8);
        end
    end

% --- BOTTOM TILE: PRH & Depth ---
    nexttile;
    yyaxis left
    
    % Conversione da Radianti a Gradi (180/pi)
    rad2deg = 180/pi;
    p_deg = pitch_vec(sensorRange) * rad2deg;
    r_deg = roll_vec(sensorRange) * rad2deg;
    h_deg = head_vec(sensorRange) * rad2deg;
    
    plot(t_sensor, p_deg, 'r', 'LineWidth', 1.5); hold on;
    plot(t_sensor, r_deg, 'g', 'LineWidth', 1.5, 'LineStyle', '--');
    plot(t_sensor, h_deg, 'b', 'LineWidth', 1.5, 'LineStyle', ':');
    
    ylabel('Degrees (PRH)', 'FontWeight', 'bold');
    
    % Regolazione dinamica dei limiti Y per vedere i piccoli movimenti
    all_vals = [p_deg; r_deg; h_deg];
    if ~isempty(all_vals)
        % Centra la visualizzazione attorno ai dati attuali con un buffer di 5 gradi
        ylim([min(all_vals)-5, max(all_vals)+5]); 
    else
        ylim([-10 10]); % Default se mancano dati
    end
    
    yyaxis right
    plot(t_sensor, depth_vec(sensorRange), 'k', 'LineWidth', 2);
    set(gca, 'YDir', 'reverse'); % Inverti profondità: il basso è più profondo
    ylabel('Depth [m]', 'FontWeight', 'bold');
    
    xlabel('Time [s] (Relative to start)', 'FontWeight', 'bold');
    legend('Pitch', 'Roll', 'Heading', 'Depth', 'Location', 'southoutside', 'Orientation', 'horizontal');
    grid on;
    xlim([T_s(1) T_s(end)]); % Sincronizzazione perfetta asse X con spettrogramma

    % 5. Salvataggio e Chiusura Figura
    exportgraphics(hFig, fullfile(saveFolder, sprintf('%03d_PRH_Acoustics.png', k)), 'Resolution', 300);
    close(hFig);
end
disp(' Processo completato: Grafici PRH-Acustica salvati.');
