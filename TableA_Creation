clc; clear; close all;

%% 1️⃣ Caricamento File (CSV e MAT)
[filename, pathname] = uigetfile('*.csv', 'Seleziona il CSV con tutti gli eventi');
if isequal(filename,0), error('Nessun file selezionato.'); end
T = readtable(fullfile(pathname, filename));

[matFile, matPath] = uigetfile('*.mat', 'Seleziona il file .mat con il vettore DN');
if isequal(matFile,0), error('Caricamento .mat annullato.'); end
matData = load(fullfile(matPath, matFile));
DN = matData.DN; 

% Controllo colonne CSV
requiredVars = {'Deployment_ID','Type','Start_duration_timestamp'};
if ~all(ismember(requiredVars, T.Properties.VariableNames))
    error('Il CSV deve contenere Deployment_ID, Type, Start_duration_timestamp');
end

Whale_ID = T.Deployment_ID{1};
pauseIdx = find(strcmp(T.Type, 'pause'));
gap_threshold = minutes(10); 

%% 2️⃣ Costruzione Tabella Unica (TS + IDX) con millisecondi
TableA_Final = table();

if length(pauseIdx) >= 2
    for i = 1:length(pauseIdx)
        % Inizializzazione Duration con precisione garantita
        End_Pause_ts = duration(NaN,0,0);
        Reg_Click_Start_ts = duration(NaN,0,0);
        Creak_Start_ts = duration(NaN,0,0);
        Pause_Start_ts = duration(NaN,0,0);
        
        needsManualInput = false;
        msg = '';
        csv_creak_row = NaN;

        % --- LOGICA DI RILEVAMENTO ---
        if i == 1
            needsManualInput = true;
            Pause_Start_ts = T.Start_duration_timestamp(pauseIdx(1));
            preIdx = 1:(pauseIdx(1)-1);
            creakPre = find(strcmp(T.Type(preIdx), 'creak'));
            if ~isempty(creakPre)
                csv_creak_row = creakPre(end);
                Creak_Start_ts = T.Start_duration_timestamp(csv_creak_row); 
            end
            msg = 'PRIMA RIGA rilevata.';
        else
            idxPrevPause = pauseIdx(i-1);
            idxCurrPause = pauseIdx(i);
            Pause_End_Prev = T.Start_duration_timestamp(idxPrevPause);
            Pause_Start_ts = T.Start_duration_timestamp(idxCurrPause);
            
            seqIdx = (idxPrevPause+1):(idxCurrPause-1);
            creakCurr_rel = find(strcmp(T.Type(seqIdx), 'creak'));
            
            if ~isempty(creakCurr_rel)
                csv_creak_row = seqIdx(creakCurr_rel(end));
                Creak_Start_ts = T.Start_duration_timestamp(csv_creak_row);
                
                if (Creak_Start_ts - Pause_End_Prev) > gap_threshold
                    needsManualInput = true;
                    msg = sprintf('SURFACING rilevato (Gap > 10m).');
                else
                    End_Pause_ts = Pause_End_Prev;
                    regIdx = seqIdx(strcmp(T.Type(seqIdx), 'regular_click'));
                    if ~isempty(regIdx), Reg_Click_Start_ts = T.Start_duration_timestamp(regIdx(1)); end
                end
            else
                End_Pause_ts = Pause_End_Prev;
            end
        end

        % --- PROMPT MANUALE (Formato SSS) ---
        if needsManualInput
            creak_info = 'Creak non trovato';
            if ~isnan(csv_creak_row), creak_info = sprintf('CSV Row: %d', csv_creak_row); end

            prompt = {['End_Pause (hh:mm:ss.SSS) - Default: ', char(End_Pause_ts)], ...
                      ['Reg_Click_Start (hh:mm:ss.SSS) - Default: ', char(Reg_Click_Start_ts)], ...
                      ['Creak_Start (', creak_info, ')'], ...
                      'Pause_Start (Già rilevata)'};
            
            dlgtitle = sprintf('%s | Seq #%d', msg, i);
            definput = {char(End_Pause_ts), char(Reg_Click_Start_ts), char(Creak_Start_ts), char(Pause_Start_ts)};
            answer = inputdlg(prompt, dlgtitle, [1 60], definput);
            
            if ~isempty(answer)
                End_Pause_ts = duration(answer{1},'InputFormat','hh:mm:ss.SSS');
                Reg_Click_Start_ts = duration(answer{2},'InputFormat','hh:mm:ss.SSS');
                Creak_Start_ts = duration(answer{3},'InputFormat','hh:mm:ss.SSS');
                Pause_Start_ts = duration(answer{4},'InputFormat','hh:mm:ss.SSS');
            end
        end

        % --- CONVERSIONE PRECISA IN INDICI ---
        ts_vals = [End_Pause_ts, Reg_Click_Start_ts, Creak_Start_ts, Pause_Start_ts];
        idx_vals = NaN(1, 4);
        
        for c = 1:4
            if ~isnan(ts_vals(c))
                % Calcolo con precisione millimetrica
                target_dn = DN(1) + seconds(ts_vals(c)) / 86400;
                [~, closest_idx] = min(abs(DN - target_dn));
                idx_vals(c) = closest_idx;
            end
        end

        % --- CREAZIONE RIGA ---
        newRow = table({Whale_ID}, ...
            End_Pause_ts, idx_vals(1), ...
            Reg_Click_Start_ts, idx_vals(2), ...
            Creak_Start_ts, idx_vals(3), ...
            Pause_Start_ts, idx_vals(4), ...
            'VariableNames', {
                'Whale_ID', ...
                'End_Pause_ts', 'End_Pause_idx', ...
                'Reg_Click_Start_ts', 'Reg_Click_idx', ...
                'Creak_Start_ts', 'Creak_idx', ...
                'Pause_Start_ts', 'Pause_idx'
            });
        
        TableA_Final = [TableA_Final; newRow];
    end
end

%% 3️⃣ Salvataggio con Formattazione Millisecondi
% Forziamo il formato millisecondi per tutte le colonne duration prima del salvataggio
TableA_Final.End_Pause_ts.Format = 'hh:mm:ss.SSS';
TableA_Final.Reg_Click_Start_ts.Format = 'hh:mm:ss.SSS';
TableA_Final.Creak_Start_ts.Format = 'hh:mm:ss.SSS';
TableA_Final.Pause_Start_ts.Format = 'hh:mm:ss.SSS';

[file, path] = uiputfile('TableA_HuntingSequences_MS_Precision.csv', 'Salva Tabella Completa');
if ischar(file)
    fullPath = fullfile(path, file);
    writetable(TableA_Final, fullPath);
    fprintf('✅ Tabella salvata con successo (Millisecondi preservati) in:\n%s\n', fullPath);
end
